// Generated using `moon info`, DON'T EDIT IT
package "Yoorkin/prettyprinter"

import(
  "moonbitlang/core/bigint"
  "moonbitlang/core/buffer"
  "moonbitlang/core/deque"
  "moonbitlang/core/immut/array"
  "moonbitlang/core/priority_queue"
  "moonbitlang/core/queue"
  "moonbitlang/core/rational"
  "moonbitlang/core/set"
)

// Values
fn braces(Document) -> Document

fn brackets(Document) -> Document

fn char(Char) -> Document

fn concat(Document, Document) -> Document

fn ctor(pkg? : String, ty? : String, String, Array[Document], labeled? : Map[String, Document]) -> Document

fn dynamic((Context) -> Document) -> Document

let empty : Document

fn flow(Array[Document]) -> Document

fn group(Document) -> Document

let hardline : Document

let line : Document

fn list(Array[Document]) -> Document

let mandatory_line : Document

let mandatory_space : Document

fn nest(indent? : Int, Document) -> Document

fn parens(Document) -> Document

fn[A : Pretty] pretty(A) -> Document

fn record(pkg? : String, ty? : String, Map[String, Document]) -> Document

fn[A : Pretty] render(A, width? : Int) -> String

fn separate(Document, Array[Document]) -> Document

fn[A] separate_map(Document, Array[A], (A) -> Document) -> Document

let softline : Document

let space : Document

fn string(String) -> Document

fn surround(Document, Document, Document) -> Document

fn switch(Document, Document) -> Document

fn text(String) -> Document

fn tuple(Array[Document]) -> Document

// Errors

// Types and methods
pub struct Context {
  indent : Int
  next_indent : Int
  width : Int
}
fn Context::current_remain(Self) -> Requirement
fn Context::next_remain(Self) -> Requirement
impl Show for Context

type Document
fn Document::requirement(Self) -> Requirement
impl Pretty for Document
impl Add for Document
impl Show for Document

pub(all) enum Requirement {
  Space(Int)
  Infinite
}
impl Add for Requirement
impl Compare for Requirement
impl Eq for Requirement
impl Show for Requirement

// Type aliases

// Traits
pub(open) trait Pretty {
  pretty(Self) -> Document
}
impl Pretty for Unit
impl Pretty for Bool
impl Pretty for Byte
impl Pretty for Char
impl Pretty for Int
impl Pretty for Int16
impl Pretty for Int64
impl Pretty for UInt
impl Pretty for UInt16
impl Pretty for UInt64
impl Pretty for Float
impl Pretty for Double
impl Pretty for String
impl[A : Pretty] Pretty for A?
impl[A : Pretty, B : Pretty] Pretty for Result[A, B]
impl[A : Pretty] Pretty for FixedArray[A]
impl Pretty for Bytes
impl Pretty for @bigint.BigInt
impl Pretty for @buffer.Buffer
impl[A : Pretty] Pretty for Array[A]
impl[A : Pretty] Pretty for Iter[A]
impl[A : Pretty, B : Pretty] Pretty for Iter2[A, B]
impl Pretty for Json
impl[A : Pretty, B : Pretty] Pretty for Map[A, B]
impl[A : Pretty] Pretty for @deque.Deque[A]
impl[A : Pretty, B : Pretty] Pretty for @moonbitlang/core/hashmap.HashMap[A, B]
impl[A : Pretty] Pretty for @moonbitlang/core/hashset.HashSet[A]
impl[A : Pretty] Pretty for @array.T[A]
impl[A : Pretty, B : Pretty] Pretty for @moonbitlang/core/immut/hashmap.HashMap[A, B]
impl[A : Pretty] Pretty for @moonbitlang/core/immut/hashset.HashSet[A]
impl[A : Pretty] Pretty for @moonbitlang/core/immut/list.T[A]
impl[A : Pretty, B : Pretty] Pretty for @moonbitlang/core/immut/sorted_map.SortedMap[A, B]
impl[A : Pretty] Pretty for @moonbitlang/core/immut/sorted_set.SortedSet[A]
impl[A : Pretty] Pretty for @moonbitlang/core/list.List[A]
impl[A : Pretty + Eq + Compare] Pretty for @priority_queue.T[A]
impl[A : Pretty] Pretty for @queue.Queue[A]
impl Pretty for @rational.T
impl[A : Pretty] Pretty for @set.Set[A]
impl[A : Pretty, B : Pretty] Pretty for @moonbitlang/core/sorted_map.SortedMap[A, B]
impl[A : Pretty] Pretty for @moonbitlang/core/sorted_set.SortedSet[A]
impl[A : Pretty, B : Pretty] Pretty for (A, B)
impl[A : Pretty, B : Pretty, C : Pretty] Pretty for (A, B, C)
impl[A : Pretty, B : Pretty, C : Pretty, D : Pretty] Pretty for (A, B, C, D)
impl[A : Pretty, B : Pretty, C : Pretty, D : Pretty, E : Pretty] Pretty for (A, B, C, D, E)
impl[A : Pretty, B : Pretty, C : Pretty, D : Pretty, E : Pretty, F : Pretty] Pretty for (A, B, C, D, E, F)
impl[A : Pretty, B : Pretty, C : Pretty, D : Pretty, E : Pretty, F : Pretty, G : Pretty] Pretty for (A, B, C, D, E, F, G)
impl[A : Pretty, B : Pretty, C : Pretty, D : Pretty, E : Pretty, F : Pretty, G : Pretty, H : Pretty] Pretty for (A, B, C, D, E, F, G, H)
impl[A : Pretty, B : Pretty, C : Pretty, D : Pretty, E : Pretty, F : Pretty, G : Pretty, H : Pretty, I : Pretty] Pretty for (A, B, C, D, E, F, G, H, I)

